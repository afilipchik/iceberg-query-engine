//! DuckDB-Validated SQL Correctness Test Suite
//!
//! Compares our query engine results against pre-generated DuckDB expected results.
//! Expected results are CSV files in tests/expected_results/, generated by
//! scripts/generate_expected_results.py using DuckDB as the oracle.
//!
//! Run with: cargo test --test duckdb_validated
//! Run specific: cargo test --test duckdb_validated validated_tpch_q01

use arrow::array::*;
use arrow::datatypes::*;
use arrow::record_batch::RecordBatch;
use query_engine::ExecutionContext;
use std::sync::OnceLock;

static CTX: OnceLock<ExecutionContext> = OnceLock::new();

/// Initialize the shared execution context by loading TPC-H parquet files.
/// Uses the same data/tpch-1mb/ directory that DuckDB loaded from.
fn get_context() -> &'static ExecutionContext {
    CTX.get_or_init(|| {
        let mut ctx = ExecutionContext::new();
        let data_dir = format!("{}/data/tpch-1mb", env!("CARGO_MANIFEST_DIR"));
        let tables = [
            "customer", "lineitem", "nation", "orders", "part", "partsupp", "region", "supplier",
        ];
        for table in &tables {
            let path = format!("{data_dir}/{table}.parquet");
            ctx.register_parquet(*table, &path)
                .unwrap_or_else(|e| panic!("Failed to load {path}: {e}"));
        }
        ctx
    })
}

// ---------------------------------------------------------------------------
// Manifest parsing
// ---------------------------------------------------------------------------

#[derive(Debug, Clone)]
struct QueryDef {
    id: String,
    sql: String,
    ordered: bool,
    row_count: usize,
    file: String,
}

fn load_manifest() -> Vec<QueryDef> {
    let manifest_path = format!(
        "{}/tests/expected_results/manifest.json",
        env!("CARGO_MANIFEST_DIR")
    );
    let data = std::fs::read_to_string(&manifest_path)
        .unwrap_or_else(|e| panic!("Failed to read manifest at {manifest_path}: {e}"));
    let entries: Vec<serde_json::Value> = serde_json::from_str(&data).unwrap();
    entries
        .into_iter()
        .map(|e| QueryDef {
            id: e["id"].as_str().unwrap().to_string(),
            sql: e["sql"].as_str().unwrap().to_string(),
            ordered: e["ordered"].as_bool().unwrap(),
            row_count: e["row_count"].as_u64().unwrap() as usize,
            file: e["file"].as_str().unwrap().to_string(),
        })
        .collect()
}

fn find_query(id: &str) -> QueryDef {
    let manifest = load_manifest();
    manifest
        .into_iter()
        .find(|q| q.id == id)
        .unwrap_or_else(|| panic!("Query '{id}' not found in manifest"))
}

// ---------------------------------------------------------------------------
// CSV parsing
// ---------------------------------------------------------------------------

fn load_expected_csv(file: &str) -> (Vec<String>, Vec<Vec<String>>) {
    let path = format!(
        "{}/tests/expected_results/{file}",
        env!("CARGO_MANIFEST_DIR")
    );
    let mut rdr = csv::ReaderBuilder::new()
        .has_headers(true)
        .from_path(&path)
        .unwrap_or_else(|e| panic!("Failed to read CSV at {path}: {e}"));

    let headers: Vec<String> = rdr
        .headers()
        .unwrap()
        .iter()
        .map(|h| h.to_string())
        .collect();
    let rows: Vec<Vec<String>> = rdr
        .records()
        .map(|r| {
            let record = r.unwrap();
            record.iter().map(|v| v.to_string()).collect()
        })
        .collect();

    (headers, rows)
}

// ---------------------------------------------------------------------------
// Arrow → String conversion
// ---------------------------------------------------------------------------

/// Format a float like Python's `{:.15g}` — full precision but no trailing zeros.
fn format_float(val: f64) -> String {
    if val == 0.0 {
        return "0".to_string();
    }
    // Format with enough precision
    let formatted = format!("{:.15}", val);
    // Strip trailing zeros after decimal point
    if formatted.contains('.') {
        let trimmed = formatted.trim_end_matches('0').trim_end_matches('.');
        if trimmed.is_empty() || trimmed == "-" {
            "0".to_string()
        } else {
            trimmed.to_string()
        }
    } else {
        formatted
    }
}

fn arrow_value_to_string(col: &ArrayRef, row: usize) -> String {
    if col.is_null(row) {
        return "\\N".to_string();
    }

    match col.data_type() {
        DataType::Boolean => {
            let arr = col.as_any().downcast_ref::<BooleanArray>().unwrap();
            if arr.value(row) {
                "true".to_string()
            } else {
                "false".to_string()
            }
        }
        DataType::Int8 => {
            let arr = col.as_any().downcast_ref::<Int8Array>().unwrap();
            arr.value(row).to_string()
        }
        DataType::Int16 => {
            let arr = col.as_any().downcast_ref::<Int16Array>().unwrap();
            arr.value(row).to_string()
        }
        DataType::Int32 => {
            let arr = col.as_any().downcast_ref::<Int32Array>().unwrap();
            arr.value(row).to_string()
        }
        DataType::Int64 => {
            let arr = col.as_any().downcast_ref::<Int64Array>().unwrap();
            arr.value(row).to_string()
        }
        DataType::UInt8 => {
            let arr = col.as_any().downcast_ref::<UInt8Array>().unwrap();
            arr.value(row).to_string()
        }
        DataType::UInt16 => {
            let arr = col.as_any().downcast_ref::<UInt16Array>().unwrap();
            arr.value(row).to_string()
        }
        DataType::UInt32 => {
            let arr = col.as_any().downcast_ref::<UInt32Array>().unwrap();
            arr.value(row).to_string()
        }
        DataType::UInt64 => {
            let arr = col.as_any().downcast_ref::<UInt64Array>().unwrap();
            arr.value(row).to_string()
        }
        DataType::Float32 => {
            let arr = col.as_any().downcast_ref::<Float32Array>().unwrap();
            format_float(arr.value(row) as f64)
        }
        DataType::Float64 => {
            let arr = col.as_any().downcast_ref::<Float64Array>().unwrap();
            format_float(arr.value(row))
        }
        DataType::Utf8 => {
            let arr = col.as_any().downcast_ref::<StringArray>().unwrap();
            arr.value(row).to_string()
        }
        DataType::LargeUtf8 => {
            let arr = col.as_any().downcast_ref::<LargeStringArray>().unwrap();
            arr.value(row).to_string()
        }
        DataType::Date32 => {
            let arr = col.as_any().downcast_ref::<Date32Array>().unwrap();
            let days = arr.value(row);
            let epoch = chrono::NaiveDate::from_ymd_opt(1970, 1, 1).unwrap();
            let date = epoch + chrono::Duration::days(days as i64);
            date.format("%Y-%m-%d").to_string()
        }
        DataType::Date64 => {
            let arr = col.as_any().downcast_ref::<Date64Array>().unwrap();
            let ms = arr.value(row);
            let epoch = chrono::NaiveDate::from_ymd_opt(1970, 1, 1).unwrap();
            let date = epoch + chrono::Duration::milliseconds(ms);
            date.format("%Y-%m-%d").to_string()
        }
        DataType::Timestamp(TimeUnit::Second, _) => {
            let arr = col.as_any().downcast_ref::<TimestampSecondArray>().unwrap();
            arr.value(row).to_string()
        }
        DataType::Timestamp(TimeUnit::Millisecond, _) => {
            let arr = col
                .as_any()
                .downcast_ref::<TimestampMillisecondArray>()
                .unwrap();
            arr.value(row).to_string()
        }
        DataType::Timestamp(TimeUnit::Microsecond, _) => {
            let arr = col
                .as_any()
                .downcast_ref::<TimestampMicrosecondArray>()
                .unwrap();
            arr.value(row).to_string()
        }
        DataType::Timestamp(TimeUnit::Nanosecond, _) => {
            let arr = col
                .as_any()
                .downcast_ref::<TimestampNanosecondArray>()
                .unwrap();
            arr.value(row).to_string()
        }
        other => panic!("Unsupported data type for comparison: {other:?}"),
    }
}

fn batches_to_string_rows(batches: &[RecordBatch]) -> Vec<Vec<String>> {
    let mut rows = Vec::new();
    for batch in batches {
        for row_idx in 0..batch.num_rows() {
            let mut row = Vec::with_capacity(batch.num_columns());
            for col_idx in 0..batch.num_columns() {
                row.push(arrow_value_to_string(batch.column(col_idx), row_idx));
            }
            rows.push(row);
        }
    }
    rows
}

// ---------------------------------------------------------------------------
// Comparison logic
// ---------------------------------------------------------------------------

/// Compare two numeric string values with tolerance.
/// Returns true if they match (within tolerance for floats, exact for integers/strings).
fn values_match(expected: &str, actual: &str) -> bool {
    // Exact match
    if expected == actual {
        return true;
    }

    // Both NULL
    if expected == "\\N" && actual == "\\N" {
        return true;
    }

    // One NULL, one not
    if expected == "\\N" || actual == "\\N" {
        return false;
    }

    // Try numeric comparison with tolerance
    if let (Ok(exp_f), Ok(act_f)) = (expected.parse::<f64>(), actual.parse::<f64>()) {
        // Handle NaN
        if exp_f.is_nan() && act_f.is_nan() {
            return true;
        }
        // Handle infinities
        if exp_f.is_infinite() && act_f.is_infinite() && exp_f.signum() == act_f.signum() {
            return true;
        }
        // Relative + absolute tolerance
        let abs_diff = (exp_f - act_f).abs();
        let rel_tol = 1e-6 * exp_f.abs().max(act_f.abs());
        let tolerance = rel_tol.max(1e-9);
        return abs_diff <= tolerance;
    }

    false
}

fn rows_match(expected: &[String], actual: &[String]) -> bool {
    if expected.len() != actual.len() {
        return false;
    }
    expected
        .iter()
        .zip(actual.iter())
        .all(|(e, a)| values_match(e, a))
}

fn sort_rows(rows: &mut [Vec<String>]) {
    rows.sort_by(|a, b| {
        for (va, vb) in a.iter().zip(b.iter()) {
            // Try numeric sort first
            if let (Ok(na), Ok(nb)) = (va.parse::<f64>(), vb.parse::<f64>()) {
                match na.partial_cmp(&nb) {
                    Some(std::cmp::Ordering::Equal) => continue,
                    Some(ord) => return ord,
                    None => {}
                }
            }
            match va.cmp(vb) {
                std::cmp::Ordering::Equal => continue,
                ord => return ord,
            }
        }
        std::cmp::Ordering::Equal
    });
}

// ---------------------------------------------------------------------------
// Main test runner
// ---------------------------------------------------------------------------

fn run_validated_query(query_id: &str) {
    let qdef = find_query(query_id);
    let ctx = get_context();

    // Load expected results
    let (_headers, mut expected_rows) = load_expected_csv(&qdef.file);

    // Run query
    let rt = tokio::runtime::Runtime::new().unwrap();
    let result = rt.block_on(async { ctx.sql(&qdef.sql).await });

    let result = match result {
        Ok(r) => r,
        Err(e) => {
            panic!(
                "Query '{}' FAILED to execute:\n  Error: {}\n  SQL: {}",
                query_id, e, qdef.sql
            );
        }
    };

    let mut actual_rows = batches_to_string_rows(&result.batches);

    // Row count check
    if expected_rows.len() != actual_rows.len() {
        let exp_preview: Vec<_> = expected_rows.iter().take(5).collect();
        let act_preview: Vec<_> = actual_rows.iter().take(5).collect();
        panic!(
            "Query '{}' ROW COUNT MISMATCH:\n  Expected: {} rows\n  Actual:   {} rows\n\n  Expected (first 5): {:#?}\n  Actual (first 5):   {:#?}\n\n  SQL: {}",
            query_id,
            expected_rows.len(),
            actual_rows.len(),
            exp_preview,
            act_preview,
            qdef.sql,
        );
    }

    // Sort unordered results before comparison
    if !qdef.ordered {
        sort_rows(&mut expected_rows);
        sort_rows(&mut actual_rows);
    }

    // Compare row-by-row
    let mut mismatches = Vec::new();
    for (i, (exp, act)) in expected_rows.iter().zip(actual_rows.iter()).enumerate() {
        if !rows_match(exp, act) {
            mismatches.push((i, exp.clone(), act.clone()));
            if mismatches.len() >= 10 {
                break;
            }
        }
    }

    if !mismatches.is_empty() {
        let mut msg = format!(
            "Query '{}' DATA MISMATCH ({} rows differ):\n",
            query_id,
            mismatches.len()
        );
        for (i, exp, act) in &mismatches {
            msg.push_str(&format!("\n  Row {i}:\n"));
            for (col_idx, (e, a)) in exp.iter().zip(act.iter()).enumerate() {
                if !values_match(e, a) {
                    msg.push_str(&format!("    Col {col_idx}: expected={e}, actual={a}\n"));
                }
            }
        }
        msg.push_str(&format!("\n  SQL: {}", qdef.sql));
        panic!("{msg}");
    }
}

// ---------------------------------------------------------------------------
// Test macro and test definitions
// ---------------------------------------------------------------------------

macro_rules! duckdb_validated_test {
    ($name:ident, $query_id:expr) => {
        #[test]
        fn $name() {
            run_validated_query($query_id);
        }
    };
    ($name:ident, $query_id:expr, ignore: $reason:expr) => {
        #[test]
        #[ignore = $reason]
        fn $name() {
            run_validated_query($query_id);
        }
    };
}

// TPC-H queries (22)
duckdb_validated_test!(validated_tpch_q01, "tpch/q01");
duckdb_validated_test!(validated_tpch_q02, "tpch/q02");
duckdb_validated_test!(validated_tpch_q03, "tpch/q03");
duckdb_validated_test!(validated_tpch_q04, "tpch/q04");
duckdb_validated_test!(validated_tpch_q05, "tpch/q05");
duckdb_validated_test!(validated_tpch_q06, "tpch/q06");
duckdb_validated_test!(validated_tpch_q07, "tpch/q07");
duckdb_validated_test!(validated_tpch_q08, "tpch/q08");
duckdb_validated_test!(validated_tpch_q09, "tpch/q09");
duckdb_validated_test!(validated_tpch_q10, "tpch/q10");
duckdb_validated_test!(validated_tpch_q11, "tpch/q11");
duckdb_validated_test!(validated_tpch_q12, "tpch/q12");
duckdb_validated_test!(validated_tpch_q13, "tpch/q13");
duckdb_validated_test!(validated_tpch_q14, "tpch/q14");
duckdb_validated_test!(validated_tpch_q15, "tpch/q15");
duckdb_validated_test!(validated_tpch_q16, "tpch/q16");
duckdb_validated_test!(validated_tpch_q17, "tpch/q17");
duckdb_validated_test!(validated_tpch_q18, "tpch/q18");
duckdb_validated_test!(validated_tpch_q19, "tpch/q19");
duckdb_validated_test!(validated_tpch_q20, "tpch/q20");
duckdb_validated_test!(validated_tpch_q21, "tpch/q21");
duckdb_validated_test!(validated_tpch_q22, "tpch/q22");

// Basic SELECT & WHERE (8)
duckdb_validated_test!(validated_basic_select_all_nation, "basic/select_all_nation");
duckdb_validated_test!(validated_basic_select_columns, "basic/select_columns");
duckdb_validated_test!(validated_basic_where_equals, "basic/where_equals");
duckdb_validated_test!(validated_basic_where_comparison, "basic/where_comparison");
duckdb_validated_test!(validated_basic_where_and_or, "basic/where_and_or");
duckdb_validated_test!(validated_basic_where_like, "basic/where_like");
duckdb_validated_test!(validated_basic_where_between, "basic/where_between");
duckdb_validated_test!(validated_basic_where_in_list, "basic/where_in_list");

// ORDER BY & LIMIT (6)
duckdb_validated_test!(validated_orderby_asc_desc, "orderby/asc_desc");
duckdb_validated_test!(validated_orderby_desc, "orderby/desc");
duckdb_validated_test!(validated_orderby_limit_offset, "orderby/limit_offset");
duckdb_validated_test!(validated_orderby_multi_column, "orderby/multi_column");
duckdb_validated_test!(validated_orderby_expression, "orderby/expression");
duckdb_validated_test!(validated_orderby_alias, "orderby/alias");

// Aggregates & GROUP BY (10)
duckdb_validated_test!(validated_agg_count_star, "agg/count_star");
duckdb_validated_test!(validated_agg_count_column, "agg/count_column");
duckdb_validated_test!(validated_agg_sum_avg_min_max, "agg/sum_avg_min_max");
duckdb_validated_test!(validated_agg_count_distinct, "agg/count_distinct");
duckdb_validated_test!(validated_agg_group_by_single, "agg/group_by_single");
duckdb_validated_test!(validated_agg_group_by_multiple, "agg/group_by_multiple");
duckdb_validated_test!(validated_agg_having, "agg/having");
duckdb_validated_test!(validated_agg_with_where, "agg/with_where");
duckdb_validated_test!(validated_agg_expression_group, "agg/expression_group");
duckdb_validated_test!(validated_agg_empty_result, "agg/empty_result");

// Joins (10)
duckdb_validated_test!(validated_join_inner, "join/inner");
duckdb_validated_test!(validated_join_left, "join/left");
duckdb_validated_test!(validated_join_right, "join/right");
duckdb_validated_test!(validated_join_full_outer, "join/full_outer");
duckdb_validated_test!(validated_join_cross, "join/cross");
duckdb_validated_test!(validated_join_self, "join/self");
duckdb_validated_test!(validated_join_multi_way, "join/multi_way");
duckdb_validated_test!(validated_join_with_aggregate, "join/with_aggregate");
duckdb_validated_test!(validated_join_with_filter, "join/with_filter");
duckdb_validated_test!(validated_join_inequality, "join/inequality");

// Subqueries (8)
duckdb_validated_test!(validated_subquery_scalar, "subquery/scalar");
duckdb_validated_test!(validated_subquery_in, "subquery/in");
duckdb_validated_test!(validated_subquery_not_in, "subquery/not_in");
duckdb_validated_test!(validated_subquery_exists, "subquery/exists");
duckdb_validated_test!(validated_subquery_not_exists, "subquery/not_exists");
duckdb_validated_test!(
    validated_subquery_correlated_scalar,
    "subquery/correlated_scalar"
);
duckdb_validated_test!(validated_subquery_from_clause, "subquery/from_clause");
duckdb_validated_test!(validated_subquery_nested, "subquery/nested");

// Expressions & Functions (8)
duckdb_validated_test!(validated_expr_arithmetic, "expr/arithmetic");
duckdb_validated_test!(validated_expr_case_when, "expr/case_when");
duckdb_validated_test!(validated_expr_coalesce_nullif, "expr/coalesce_nullif");
duckdb_validated_test!(validated_expr_cast, "expr/cast");
duckdb_validated_test!(validated_expr_string_functions, "expr/string_functions");
duckdb_validated_test!(validated_expr_math_functions, "expr/math_functions");
duckdb_validated_test!(validated_expr_date_extract, "expr/date_extract");
duckdb_validated_test!(validated_expr_trim_replace, "expr/trim_replace");

// DISTINCT (3)
duckdb_validated_test!(validated_distinct_simple, "distinct/simple");
duckdb_validated_test!(validated_distinct_multi_column, "distinct/multi_column");
duckdb_validated_test!(
    validated_distinct_with_expression,
    "distinct/with_expression"
);

// Set Operations (4)
duckdb_validated_test!(validated_setop_union, "setop/union");
duckdb_validated_test!(validated_setop_union_all, "setop/union_all");
duckdb_validated_test!(validated_setop_intersect, "setop/intersect");
duckdb_validated_test!(validated_setop_except, "setop/except");

// Complex / Multi-Feature (7)
duckdb_validated_test!(
    validated_complex_nested_subquery_agg,
    "complex/nested_subquery_agg"
);
duckdb_validated_test!(
    validated_complex_multi_join_having,
    "complex/multi_join_having"
);
duckdb_validated_test!(validated_complex_cte_with_join, "complex/cte_with_join");
duckdb_validated_test!(
    validated_complex_derived_table_chain,
    "complex/derived_table_chain"
);
duckdb_validated_test!(
    validated_complex_case_in_aggregate,
    "complex/case_in_aggregate"
);
duckdb_validated_test!(
    validated_complex_exists_with_aggregate,
    "complex/exists_with_aggregate"
);
duckdb_validated_test!(
    validated_complex_union_with_aggregate,
    "complex/union_with_aggregate"
);

// =========================================================================
// P1 — SQL Feature Gaps (11 queries)
// =========================================================================

duckdb_validated_test!(validated_basic_is_null, "basic/is_null");
duckdb_validated_test!(validated_basic_is_null_filter, "basic/is_null_filter");
duckdb_validated_test!(validated_basic_not_like, "basic/not_like");
duckdb_validated_test!(validated_basic_not_between, "basic/not_between");
duckdb_validated_test!(validated_basic_standalone_or, "basic/standalone_or");
duckdb_validated_test!(validated_basic_not_operator, "basic/not_operator");
duckdb_validated_test!(validated_complex_multiple_ctes, "complex/multiple_ctes");
duckdb_validated_test!(
    validated_agg_having_without_group_by,
    "agg/having_without_group_by"
);
duckdb_validated_test!(validated_orderby_offset_only, "orderby/offset_only");
duckdb_validated_test!(
    validated_basic_aliased_subquery_join,
    "basic/aliased_subquery_join"
);
duckdb_validated_test!(validated_basic_nested_not, "basic/nested_not");

// =========================================================================
// P1 — String Functions (13 queries)
// =========================================================================

duckdb_validated_test!(validated_func_concat, "func/concat");
duckdb_validated_test!(validated_func_concat_ws, "func/concat_ws");
duckdb_validated_test!(validated_func_left_right, "func/left_right");
duckdb_validated_test!(validated_func_reverse, "func/reverse");
duckdb_validated_test!(validated_func_lpad_rpad, "func/lpad_rpad");
duckdb_validated_test!(validated_func_starts_ends_with, "func/starts_ends_with");
duckdb_validated_test!(validated_func_split_part, "func/split_part");
duckdb_validated_test!(validated_func_repeat, "func/repeat_func");
duckdb_validated_test!(validated_func_chr_ascii, "func/chr_ascii");
duckdb_validated_test!(validated_func_strpos, "func/strpos");
duckdb_validated_test!(validated_func_translate, "func/translate");
duckdb_validated_test!(validated_func_string_combined, "func/string_combined");
duckdb_validated_test!(validated_func_substring_variants, "func/substring_variants");

// =========================================================================
// P2 — Date/Time Functions (8 queries)
// =========================================================================

duckdb_validated_test!(validated_func_date_add, "func/date_add");
duckdb_validated_test!(validated_func_date_diff, "func/date_diff");
duckdb_validated_test!(validated_func_date_comparison, "func/date_comparison");
duckdb_validated_test!(validated_func_year_month_day, "func/year_month_day");
duckdb_validated_test!(validated_func_date_part, "func/date_part");
duckdb_validated_test!(validated_func_current_date_test, "func/current_date_test");
duckdb_validated_test!(validated_func_last_day_of_month, "func/last_day_of_month");
duckdb_validated_test!(validated_func_date_arithmetic, "func/date_arithmetic");

// =========================================================================
// P2 — Math Functions (8 queries)
// =========================================================================

duckdb_validated_test!(validated_func_power_sqrt, "func/power_sqrt");
duckdb_validated_test!(validated_func_mod_sign, "func/mod_sign");
duckdb_validated_test!(validated_func_ln_log_exp, "func/ln_log_exp");
duckdb_validated_test!(validated_func_trig_functions, "func/trig_functions");
duckdb_validated_test!(validated_func_degrees_radians, "func/degrees_radians");
duckdb_validated_test!(validated_func_truncate_func, "func/truncate_func");
duckdb_validated_test!(validated_func_pi_e, "func/pi_e");
duckdb_validated_test!(validated_func_math_on_data, "func/math_on_data");

// =========================================================================
// P2 — Regex Functions (4 queries)
// =========================================================================

duckdb_validated_test!(validated_func_regexp_like, "func/regexp_like");
duckdb_validated_test!(validated_func_regexp_extract, "func/regexp_extract");
duckdb_validated_test!(validated_func_regexp_replace, "func/regexp_replace");
duckdb_validated_test!(validated_func_regexp_on_data, "func/regexp_on_data");

// =========================================================================
// P2 — Conditional Functions (5 queries)
// =========================================================================

duckdb_validated_test!(validated_func_if_func, "func/if_func");
duckdb_validated_test!(validated_func_greatest_least, "func/greatest_least");
duckdb_validated_test!(
    validated_func_greatest_least_data,
    "func/greatest_least_data"
);
duckdb_validated_test!(validated_func_try_cast, "func/try_cast");
duckdb_validated_test!(validated_func_coalesce_chain, "func/coalesce_chain");

// =========================================================================
// P2 — Aggregate Functions (8 queries)
// =========================================================================

duckdb_validated_test!(validated_agg_stddev_variance, "agg/stddev_variance");
duckdb_validated_test!(validated_agg_bool_agg, "agg/bool_agg");
duckdb_validated_test!(validated_agg_min_max_by, "agg/min_max_by");
duckdb_validated_test!(validated_agg_count_if, "agg/count_if");
duckdb_validated_test!(validated_agg_sum_distinct, "agg/sum_distinct");
duckdb_validated_test!(validated_agg_multiple_distinct, "agg/multiple_distinct");
duckdb_validated_test!(validated_agg_nested_agg_subquery, "agg/nested_agg_subquery");
duckdb_validated_test!(validated_agg_group_by_expression, "agg/group_by_expression");

// =========================================================================
// P3 — Binary/Encoding Functions (4 queries)
// =========================================================================

duckdb_validated_test!(validated_func_hex_functions, "func/hex_functions");
duckdb_validated_test!(validated_func_md5_sha, "func/md5_sha");
duckdb_validated_test!(validated_func_base64, "func/base64");
duckdb_validated_test!(validated_func_encode_combined, "func/encode_combined");

// =========================================================================
// P3 — Bitwise Functions (3 queries)
// =========================================================================

duckdb_validated_test!(validated_func_bitwise_ops, "func/bitwise_ops");
duckdb_validated_test!(validated_func_bitwise_shift, "func/bitwise_shift");
duckdb_validated_test!(validated_func_bit_count, "func/bit_count");

// =========================================================================
// P3 — Additional Complex Queries (6 queries)
// =========================================================================

duckdb_validated_test!(
    validated_complex_correlated_exists_multiple,
    "complex/correlated_exists_multiple"
);
duckdb_validated_test!(
    validated_complex_subquery_in_select,
    "complex/subquery_in_select"
);
duckdb_validated_test!(
    validated_complex_deeply_nested_subquery,
    "complex/deeply_nested_subquery"
);
duckdb_validated_test!(
    validated_complex_multi_agg_multi_join,
    "complex/multi_agg_multi_join"
);
duckdb_validated_test!(validated_complex_case_grouping, "complex/case_grouping");
duckdb_validated_test!(validated_complex_union_cte, "complex/union_cte");
